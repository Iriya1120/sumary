### html5十个新特性 ###

1. 标签语义化
2. 增强型表单 如color、 email、 date、 tel等
3. 视频和音频
4. canvas绘图
5. svg绘图
6. 地理定位API
7. 拖放API      dragstart： 拖动开始；drag：拖动中；dragend：拖动结束
8. Web Worker
9. Web Storage 分为localStorage和sessionStorage
10. WebSocket


### CSS绘制三角形的方式 ###
1. border
2. canvas绘图
3. svg绘图
4. 线性渐变，45deg
5. clip-path: polygon()


### BFC ###
- 定义： 块级格式化上下文，如果一个元素设置了BFC，那么其内部元素不会影响外部元素，外部元素也不会影响内部元素
- 可以解决哪些问题：
  1. 清除浮动
  2. 防止外边距重叠
  3. 防止元素被浮动元素覆盖
- 怎么设置BFC：
  1. html 根元素
  2. float不是none的元素
  3. position不是static或relative的元素
  4. display的值是inline-block,table-cell,table-caption,flex,inline-flex
  5. overflow不是visible的元素


### flex弹性布局 ###
- 属性
  1. **flex-direction**: 主轴的方向（row、column、row-reverse、column-reverse）
  2. **flex-wrap**: 是否换行(nowrap、wrap、wrap-reverse)
  3. **flex-flow**: flex-driection与flex-wrap的组合（row nowrap）
  4. **justify-content**: 项目在主轴上的对齐方式（flex-start、flex-end、center、space-between、space-around）
  5. **align-items**: 项目在侧轴上的对齐方式（flex-start、flex-end、center、baseline[第一行文字为基准线]、stretch[拉伸]）
  6. **align-content**: 多根轴线的对齐方式(flex-start、flex-end、center、space-between、space-around、stretch)
- 项目的属性：
  1. order: 显示的顺序（越小越靠前）
  2. flex-grow: 定义项目的放大比例(默认为0，即不放大，如果全为1，则平分剩余空间[其实就是flex属性])
  3. flex-shrink: 定义了项目的缩小比例(默认为1，如果空间不足，将会缩小)
  4. flex-basis: 定义了在分配多余空间之前，项目占据的主轴空间
  5. flex: 是flex-grow、flex-shrink、flex-basic的组合缩写(默认值是 0 1 auto)
  6. align-self: 允许单个项目有与其他项目不一样的对齐方式(auto、flex-start、flex-end、center、baseline、stretch)


### 水平垂直居中 ### 
- 不固定：
  1. flex
  2. table-cell
  3. transform(-50%, -50%)
  4. grid布局
- 固定：
  1. abslute + margin:auto
  2. abslute + 负margin


### 清除浮动 ###
1. 尾部添加元素设置clear: both
2. 伪元素after
3. BFC
4. 父元素也设置浮动


### 选择器优先级 ###
**!important > 行内样式 > ID选择器 > 类选择器 > 标签 > 通配符 > 继承 > 浏览器默认属性**


### CSS3新特性 ###
1. 新增了一些选择器
2. 边框和背景
3. 渐变(gradients) 线性渐变： linear-gradients、  径向渐变：radial-gradient
4. 转换(transform)
5. 过渡(transition)  transition-property、 transition-duration、 transition-timing-function、 transition-delay
6. 动画(animation)
7. 盒模型
8. 弹性布局(flex)
9. 媒体查询


### JS基本数据类型 ###
1. String
2. Number
3. Null
4. Undefined
5. Boolean
6. Symbol
7. Bigint


### JS隐式类型转换规则 ###
1. 遇到 == ， 两边转化成number类型进行比较
2. 遇到 ！操作符，首先转化成Boolean类型
3. null == undefined 结果为true
4. 遇到大小比较时，如果两边是String，则直接比较unicode， 如果有一边是Number， 则转化成Number比较
5. 遇到字符串 + ， 转化成字符串拼接
6. 遇到 ++ -- ，转化成Number
7. 在进行 == 比较时， null与undefined不会转换类型(重要！！！！)


### 原型与原型链 ###
- 理解： 原型本质上是一个对象，是为了给实例添加一组属性和方法存在的，JS在寻找实例的属性的时候，首先会在实例本身的属性去找，如果没有找到，
  那么就会去它的原型对象里面找，如果还没有找到，就会继续去这个原型的原型找，直到找到这个属性或是找到原型的顶点为止。原型对象之间的这种层层递进的关系就形成了原型链。

1. 实例的__proto__属性指向其构造函数的 prototype 属性
2. 构造函数的__proto__属性指向 Function 的 prototype 属性
3. Function 的 prototype 的__proto__属性指向 Object 的 prototype 属性


### JS闭包 ###
- 理解： 闭包就是能够访问其他函数内部变量的函数
- 可能导致的问题： 内存泄露(原因是变量不会被销毁)


### 事件 ###
1. 事件捕获
2. 事件冒泡
3. 事件代理
4. 阻止事件冒泡的方式：stopPropagation()、 cancelBubble = true(IE)
5. 阻止默认事件的方式：preventDefault()、 returnValue = false(IE)


### 事件循环EventLoop ###
- 理解： 由于JS单线程执行的缘故，如果所有任务都同步执行，那么在某些操作上就会让CPU处于空闲等待状态，于是任务就被分成了同步执行跟异步执行
  两种，异步执行的任务又分为宏任务和微任务。于是JS的执行机制就是所有的同步任务都在主线程上执行，同时在主线程之外还有一个任务队列，当异步任务执行有了结果后，就会在任务队列里添加一个事件。一旦执行栈中的同步任务执行完毕，系统就会读取任务队列，将其放到执行栈中执行，主线程会不断重复地去执行这个过程，这就是事件循环


### 宏任务与微任务 ###
- 宏任务：
  1. script (外层同步代码)
  2. setTimeout / setInterval
  3. UI事件
  4. postMessage，MessageChannel
  5. setImmediate，I/O（Node.js）
- 微任务：
  1. Promise
  2. MutaionObserver
  3. Object.observe
  4. process.nextTick（Node.js）


### 数组方法apply、bind、call的作用 ###
- 理解： 用于修改方法内部的 this 指向
- 格式：
  1. apply: xxx.apply(context, [参数1， 参数2， ..., 参数n])
  2. call: xxx.call(context, 参数1， 参数2， ..., 参数n)
  3. bind: xxx.bind(context, 参数1， 参数2， ..., 参数n)()


### 浅拷贝与深拷贝 ###
- 浅拷贝：
  1. Object.create()
  2. Object.assign()
  3. 扩展运算符 ...
- 深拷贝：
  1. JSON.parse(JSON.stringify(xxx))
  2. 递归


### 数组的方法 ###
- 改变自身的：
  1. splice(位置，删除个数，新增个数);
  2. pop() 返回删除元素
  3. push(插入元素) 返回长度
  4. unshift(插入首部的元素) 返回长度
  5. shift() 返回删除的头部元素
  6. reverse() 倒序
  7. sort() 排序
  8. fill(填充值, 开始, 结束)；
- 不改变自身的：
  1. slice(开始,结束) 截取
  2. indexOf(字符) 查询指定字符 不存在返回-1
  3. lastIndexOf(字符) 倒序查询
  4. concat(连接数字)
  5. join(符号) 数组转字符串
  6. includes(字符) 有返回true


### 防抖和节流 ###
- 理解： 防抖是指在一定时间间隔内触发的多次事件只会处理最后一次，每次触发都会重新计时；节流是在一定时间间隔内触发的多次时间只会被处理第
  一次，处理后不会重新计时。
- 作用： 防抖和节流能有效减少浏览器引擎的损耗，防止出现页面堵塞卡顿现象


### 数组扁平化处理 ###
1. flat(Infinity)
2. toString() + split(',') + join('')
3. 递归


### 从输入一个url到显示页面的过程 ###
1. DNS域名解析
2. 三次握手建立连接
3. 客户端发起请求
4. 服务端返回页面资源
5. 浏览器解析资源并显示
6. 四次挥手释放连接


### DNS域名解析过程 ###
1. 浏览器缓存
2. 系统缓存(hosts文件)
3. 路由器缓存
4. 本地缓存(运营商)
5. 根域名服务器
6. 顶级域名服务器
7. 权威域名服务器


### 根域名服务器查找IP的方式 ###
1. 迭代查询(返回最终查询结果)
2. 递归查询(返回每一次查询结果)


### tcp三次握手过程 ###
- 理解： 三次握手首先是由客户端发起，将SYN位置为1请求建立连接，服务端收到后给客户端一个响应，同时也将SYN置为1，这时对于
  客户端来说，已经知道了所有的信息，即它既可以给服务端发送请求，也可以收到服务端的响应，但是对于服务端来说，它只知道能够接收到客户端的请求，它发送给客户端的响应对方能否收到它是不知道的，所以必须进行第三次握手，这样才能建立可靠的连接。


### 四次挥手过程 ###
- 理解： 四次挥手首先是由客户端发起一个释放连接的请求，将FIN位置为1，服务端收到这个请求后给客户端一个响应表示收到了这个请求，等待服务端没
  有数据发送之后就会再次向客户端发起一个释放连接的请求，同时将FIN位置为1，客户端收到，返回确认释放连接的响应，ACK置为1。


### TCP与UDP的区别 ###
- tcp：
  1. 面向连接
  2. 可靠
  3. 面向字节流
  4. 一对一通信
  5. 拥塞控制
- udp：
  1. 无连接
  2. 不可靠
  3. 面向报文
  4. 能够一对一，一对多，多对一，多对多通信
  5. 没有拥塞控制


### HTTP缓存 ###
1. 强制缓存：cache-control 设置为 max-age
2. 协商缓存：cache-control 设置为 no-cache
  - 注意： 一般两种缓存机制是共同运行的，因为cache-control可以设置多个值，用逗号分隔。
  - 浏览器一般是先判断缓存有没有过期，如果没有，直接使用缓存(强制缓存策略)，如果过期了，同时设置了协商缓存，那么就会去判断协商缓存是否过期
    如果没有过期，就会返回304状态码，使用本地缓存，如果过期了，就会重新请求更新数据
  - 协商缓存通过设置last-modified(精确到秒，秒以内多次操作必须使用etag才能检测到) 和 etag 请求， 响应中对应if-modified-since和
    if-none-match


### get请求和post请求的区别 ###
- 网络层面：post请求需要发起两次请求，get请求仅需一次
- 浏览器层面：
  1. get请求的长度限制
  2. get请求需要进行url编码
  3. post请求相对于get请求比较安全一些，因为请求参数不是携带在url上
  4. get请求会被浏览器主动缓存


### 拥塞控制 ###
1. 慢开始(x2)
2. 快重传：当连续三次收到相同的确认包（立即重传）
3. 快恢复(减半并拥塞避免)
4. 拥塞避免(加法增大[线性])


### vue的组件通信 ###
- 父子组件
  1. prop
  2. $emit
  3. $parent + $children
  4. ref
- 兄弟组件
  1. prop + $emit
  2. eventBus
  3. vuex


### diff 算法 ###
- 理解：最小量更新算法。先将DOM生成虚拟DOM树
- 在采取diff算法比较新旧节点的时候，比较只会在同层级进行, 不会跨层级比较。



