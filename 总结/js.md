### JS基本数据类型 ###
1. String
2. Number
3. Null
4. Undefined
5. Boolean
6. Symbol
7. Bigint


### JS隐式类型转换规则 ###
1. 遇到 == ， 两边转化成number类型进行比较
2. 遇到 ！操作符，首先转化成Boolean类型
3. null == undefined 结果为true
4. 遇到大小比较时，如果两边是String，则直接比较unicode， 如果有一边是Number， 则转化成Number比较
5. 遇到字符串 + ， 转化成字符串拼接
6. 遇到 ++ -- ，转化成Number
7. 在进行 == 比较时， null与undefined不会转换类型(重要！！！！)


### 原型与原型链 ###
- 理解： 原型本质上是一个对象，是为了给实例添加一组属性和方法存在的，JS在寻找实例的属性的时候，首先会在实例本身的属性去找，如果没有找到，
  那么就会去它的原型对象里面找，如果还没有找到，就会继续去这个原型的原型找，直到找到这个属性或是找到原型的顶点为止。原型对象之间的这种层层递进的关系就形成了原型链。
1. 实例的__proto__属性指向其构造函数的 prototype 属性
2. 构造函数的__proto__属性指向 Function 的 prototype 属性
3. Function 的 prototype 的__proto__属性指向 Object 的 prototype 属性


### JS闭包 ###
- 理解： 闭包就是能够访问其他函数内部变量的函数
- 可能导致的问题： 内存泄露(原因是变量不会被销毁)


### 事件 ###
1. 事件捕获
2. 事件冒泡
3. 事件代理
4. 阻止事件冒泡的方式：stopPropagation()、 cancelBubble = true(IE)
5. 阻止默认事件的方式：preventDefault()、 returnValue = false(IE)


### 事件循环EventLoop ###
- 理解： 由于JS单线程执行的缘故，如果所有任务都同步执行，那么在某些操作上就会让CPU处于空闲等待状态，于是任务就被分成了同步执行跟异步执行
  两种，异步执行的任务又分为宏任务和微任务。于是JS的执行机制就是所有的同步任务都在主线程上执行，同时在主线程之外还有一个任务队列，当异步任务执行有了结果后，就会在任务队列里添加一个事件。一旦执行栈中的同步任务执行完毕，系统就会读取任务队列，将其放到执行栈中执行，主线程会不断重复地去执行这个过程，这就是事件循环


### 宏任务与微任务 ###
- 宏任务：
  1. script (外层同步代码)
  2. setTimeout / setInterval
  3. UI事件
  4. postMessage，MessageChannel
  5. setImmediate，I/O（Node.js）
- 微任务：
  1. Promise
  2. MutaionObserver
  3. Object.observe
  4. process.nextTick（Node.js）


### 数组方法apply、bind、call的作用 ###
- 理解： 用于修改方法内部的 this 指向
- 格式：
  1. apply: xxx.apply(context, [参数1， 参数2， ..., 参数n])
  2. call: xxx.call(context, 参数1， 参数2， ..., 参数n)
  3. bind: xxx.bind(context, 参数1， 参数2， ..., 参数n)()


### 浅拷贝与深拷贝 ###
- 浅拷贝：
  1. Object.create()
  2. Object.assign()
  3. 扩展运算符 ...
- 深拷贝：
  1. JSON.parse(JSON.stringify(xxx))
  2. 递归


### 数组的方法 ###
- 改变自身的：
  1. splice(位置，删除个数，新增个数);
  2. pop() 返回删除元素
  3. push(插入元素) 返回长度
  4. unshift(插入首部的元素) 返回长度
  5. shift() 返回删除的头部元素
  6. reverse() 倒序
  7. sort() 排序
  8. fill(填充值, 开始, 结束)；
- 不改变自身的：
  1. slice(开始,结束) 截取
  2. indexOf(字符) 查询指定字符 不存在返回-1
  3. lastIndexOf(字符) 倒序查询
  4. concat(连接数字)
  5. join(符号) 数组转字符串
  6. includes(字符) 有返回true


### 防抖和节流 ###
- 理解： 防抖是指在一定时间间隔内触发的多次事件只会处理最后一次，每次触发都会重新计时；节流是在一定时间间隔内触发的多次事件只会被处理第
  一次，处理后不会重新计时。
- 作用： 防抖和节流能有效减少浏览器引擎的损耗，防止出现页面堵塞卡顿现象


### 数组扁平化处理 ###
1. flat(Infinity)
2. toString() + split(',') + join('')
3. 递归


### 二分查找的前提条件 ###
1. 元素必须保持有序
2. 必须采用顺序存储结构


### JS的this指向 ###
- this最终指向的是那个直接调用它的对象
- 通过apply、bind、call可以改变this指向
- 在严格模式下默认的this不再是window，而是undefined
- new 操作符会改变this的指向


### JS变量提升 ###
- 理解： 变量提升是指在JS代码执行前会将变量的声明提升到作用域的顶部，等到执行到的时候再进行赋值


### 懒加载的实现方法 ###
1. 使用 scrollTop / innerTop / offsetTop 监听鼠标滚动事件
2. Intersection Observer (交叉观察)


### 基本类型与引用类型的区别 ###
1. 基本数据类型：操作的是值，并且值存储在栈内存中
2. 引用数据类型：操作的是堆内存的引用地址，并且会把对象中的键值对放在堆内存中


### 堆内存与栈内存 ###
1. 栈内存：
  - 供代码自上而下的执行
  - 存储基本数据类型值
  - 速度快，空间小
  - 会自动分配内存空间，会自动释放
2. 堆内存：
  - 存储引用数据类型的值
  - 速度较慢，空间大
  - 动态分配的内存，大小不定也不会自动释放


### 为什么要分为栈内存与堆内存 ###
1. 与垃圾回收机制有关。因为在方法调用时，会建立自己的内存栈，其内部变量会被会被放到这个内存栈里，当方法执行完就会随之销毁，但是对象不是，它被创建
   在堆内存中，只有当没有引用指向它时垃圾回收机制才会回收它。
2. 为了使程序运行时占用的内存最小。


### 垃圾回收 ###
1. 标记清除(常用)
2. 引用计数
3. 标记整理(未确定)


### ES6新特性 ###
1. var[函数级作用域] let[块级作用域] const
2. 数组 对象 函数的解构
3. Set 和 Map
4. 箭头函数
5. Promise


### null 与 undefined ###
- 区别
  1. null是一个表示"无"的对象，undefined是一个表示"无"的原始值
  2. 转数值类型的区别，null 为 0， undefined 为 NaN
  3. typeof 运算符的区别
- 用法
  1. null
    - 作为函数的参数，表示该函数的参数不是对象
    - 作为对象原型链的终点
    - 手动设置来清除对某个对象的引用
  2. undefined
    - 变量被声明了，但没有赋值时，就等于undefined。
    - 调用函数时，应该提供的参数没有提供，该参数等于undefined。
    - 对象没有赋值的属性，该属性的值为undefined。
    - 函数没有返回值时，默认返回undefined。


### WebSocket ###
- 理解：WebSocket是一种在单个TCP连接上进行全双工通信的协议
- 为什么需要: 因为HTTP的缺陷:通信只能由客户端发起
- 特点: 
  1. 客户端可以主动向服务器发送消息，服务端也可以主动向客户端发送消息
  2. 建立在 TCP 协议之上，服务器端的实现比较容易
  3. 与 HTTP 协议有着良好的兼容性
  4. 数据格式比较轻量，性能开销小，通信高效
  5. 可以发送文本，也可以发送二进制数据
  6. 没有同源限制，客户端可以与任意服务器通信
  7. 协议标识符是ws