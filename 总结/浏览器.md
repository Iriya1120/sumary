### XSS ###
- 理解： 跨站脚本攻击。通过在网站上注入恶意代码，使之在浏览器上运行，从而盗取用户信息。
- 分类：
    1. DOM式
    2. 反射式
    3. 存储式
- 预防：
    1. 过滤
    2. CSP白名单
    3. 对敏感信息保护，比如cookie设置http-only


### CSRF ###
- 理解： 跨站请求伪造。利用用户登录信息，绕过后台登录验证。本质是利用cookie在同源请求中会携带发送给服务器。
- 攻击类型：
    1. GET型
    2. POST型
    3. 链接型
- 预防：
    1. 进行同源检测
    2. 使用CSRF Token验证
    3. 双cookie验证
    4. cookie设置SameSite，限制cookie不能被第三方使用


### 网络劫持 ###
1. DNS劫持(强制跳转)
2. HTTP劫持(由于http明⽂传输,运营商会修改你的http响应内容(即加⼴告))，可以使用https，加密http。


### 进程与线程的区别 ###
1. 进程可以看作是一个独立的应用，而线程不可以
2. 进程是资源分配的最小单位，线程是调度的最小单位
3. 通信方面，线程可以共享一个进程的资源，而进程通信需要依赖进程间通信
4. 在调度上线程要快，开销要小
5. 系统开销上，进程要大一些，因为系统需要为它分配或回收资源


### 浏览器渲染进程内有哪些线程 ###
1. GUI渲染线程
2. JS引擎线程
3. 事件触发线程(控制事件循环)
4. 定时器触发线程
5. 异步http请求线程


### 进程间通信的方式 ###
1. 管道通信：管道通信就是开辟一块缓冲区，进程A将需要交互的数据拷贝到缓冲区中，进程B就可以读取了，只可以单向通信
2. 消息队列通信：消息队列就是一个消息列表。有长度限制
3. 信号量通信：在访问共享内存时，为了互斥，可以使用信号量，当进程1在使用共享内存时，就将信号量设置为0，其他进程就不可以访问。
4. 信号通信
5. 共享内存通信：共享内存就是映射一段能被其他进程所访问的内存，它是由一个进程创建，但多个进程都可以访问
6. 套接字通信：非同一台主机间进程的通信，使用Socket套接字通信


### 孤儿进程与僵尸进程 ###
1. 孤儿进程： 父进程结束了，但是它的一个或多个子进程还在运行，这些子进程就是孤儿进程
2. 僵尸进程： 子进程结束了，但是父进程还保留着它的描述，也没有释放它占有的空间，这种进程就是僵尸进程


### 死锁 ###
- 理解： 死锁就是指多个进程在运行中因为争夺资源而产生的僵局，若无外力作用，将无法向前推进。
- 产生原因：
    1. 竞争资源
    2. 进程间推进顺序非法
- 产生条件：
    1. 互斥条件
    2. 请求和保持条件
    3. 不剥夺条件
    4. 环路等待条件
- 预防措施：
    1. 资源一次性分配
    2. 只要有一个资源得不到分配，也不给这个进程分配其他资源
    3. 对于可剥夺资源，如果得不到，就释放
    4. 编号分配资源


### 如何实现不同标签页的通信 ###
1. 使用websocket协议
2. shareWorker(这是一个唯一的线程)
3. localStorage
4. postMessage


### 浏览器资源缓存的位置有哪些 ###
1. Service Worker
2. 内存缓存
3. 硬盘缓存


### 为什么需要缓存 ###
1. 可以减少服务器负担
2. 加快了客户端加载的速度
3. 减少多余的网络请求


### 刷新与强制刷新还有地址栏回车有什么区别 ###
- 刷新会判断缓存。强制刷新不会使用缓存。地址栏回车相当于正常请求


### 浏览器渲染过程 ###
1. 解析文档构建DOM树
2. 解析CSS，构建CSSOM
3. 根据DOM树和CSSOM构建渲染树
4. 构建绘制顺序表
5. 根据渲染树生成图层树
6. 删格线程根据绘制顺序和图层进行删格化(生成图块)
7. 合成器收集图块合成合成器帧
8. 通过IPC将合成器帧传给浏览器进程进行渲染


### 浏览器渲染优化 ###
- 针对JS
    1. 尽量将JS放在body最后
    2. body中尽量不要写script标签
    3. 异步加载JS: async 与 defer
        - async: 下载完成后立即执行，不保证执行顺序
        - defer: 下载完成后会等待DOM解析完成后执行，而且是按顺序执行
- 针对CSS
    1. 尽量少用@import， 因为它会暂停渲染去服务器加载资源文件。
- 针对回流与重绘
    1. 尽量少使用可能引起回流与重绘的操作
    2. 浏览器对回流重绘有自己的优化(渲染队列[当队列内的操作达到一定数量或者一定时间间隔就会批处理])


### 文档预解析 ###
- 理解： 文档预解析是指在遇到JS脚本时，利用另外一个线程继续解析剩下的文档和网络请求。


### cookie，localStorage，sessionStorage，indexDB区别 ###
- cookie: 
  cookie是由服务器生成的，可以设置过期时间，大小只有4k，同时一个域名下cookie不得超过20个，cookie在请求一个新的页面的时候会被携带，有安全问题，截获cookie就可以获得session信息。同时cookie是无法跨域的，如果需要跨域共享cookie，可以使用Nginx反向代理或者在一个站点登录后，向其他站点写入cookie。
  使用场景: 存储sessionId、统计页面点击次数
- localStorage: 
  localStorage可以存储更多的数据，它的大小有5M，持久存储，并不会随着页面关闭消失，除非手动清理，否则一直存在，不会参与页面请求。在隐私模式下无法访问，受同源限制。
  使用场景: 不常更换的用户信息
- sessionStorage:
  sessionStorage与localStorage有很多相同点，它们都是本地存储，大小都是5M，都受同源限，但是sessionStorage只有在同浏览器同页面才能共享
  使用场景: 由于sessionStorage的时效性，可以用来存储用户登录信息
- indexedDB:
  特点: 键值对存储、异步、同源限制、支持二进制存储、支持事务存储空间大(一般不小于250M甚至无限制)


### 同源策略限制 ###
- 理解： 同源策略限制了一个源的文档和脚本怎么跟另一个源交互，它指的是协议、域名、端口必须一致
- 主要限制三个方面:
  1. 当前域下的JS脚本不能访问其他域下的cookie、localStorage、sessionStorage
  2. 当前域下的JS脚本不能操作其他域下的DOM
  3. 当前域下的Ajax无法发送跨域请求
- 为什么要引入同源策略:
  1. 为了保证用户的信息安全。


### 怎么解决跨域问题 ###
1. 跨域源资源共享(CORS): 为某个源指定可以访问的跨域源