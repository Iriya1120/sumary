### 从输入一个url到显示页面的过程 ###
1. DNS域名解析
2. 三次握手建立连接
3. 客户端发起请求
4. 服务端返回页面资源
5. 浏览器解析资源并显示
6. 四次挥手释放连接


### DNS域名解析过程 ###
1. 浏览器缓存
2. 系统缓存(hosts文件)
3. 路由器缓存
4. 本地缓存(运营商)
5. 根域名服务器
6. 顶级域名服务器
7. 权威域名服务器


### 根域名服务器查找IP的方式 ###
1. 迭代查询(返回最终查询结果)
2. 递归查询(返回每一次查询结果)


### tcp三次握手过程 ###
- 理解： 三次握手首先是由客户端发起，将SYN位置为1请求建立连接，服务端收到后给客户端一个响应，同时也将SYN置为1，这时对于
  客户端来说，已经知道了所有的信息，即它既可以给服务端发送请求，也可以收到服务端的响应，但是对于服务端来说，它只知道能够接收到客户端的请求，它发送给客户端的响应对方能否收到它是不知道的，所以必须进行第三次握手，这样才能建立可靠的连接。


### 四次挥手过程 ###
- 理解： 四次挥手首先是由客户端发起一个释放连接的请求，将FIN位置为1，服务端收到这个请求后给客户端一个响应表示收到了这个请求，等待服务端没
  有数据发送之后就会再次向客户端发起一个释放连接的请求，同时将FIN位置为1，客户端收到，返回确认释放连接的响应，ACK置为1。


### TCP与UDP的区别 ###
- tcp：
  1. 面向连接
  2. 可靠
  3. 面向字节流
  4. 一对一通信
  5. 拥塞控制
- udp：
  1. 无连接
  2. 不可靠
  3. 面向报文
  4. 能够一对一，一对多，多对一，多对多通信
  5. 没有拥塞控制


### HTTP缓存 ###
1. 强制缓存：cache-control 设置为 max-age
2. 协商缓存：cache-control 设置为 no-cache
  - 注意： 一般两种缓存机制是共同运行的，因为cache-control可以设置多个值，用逗号分隔。
  - 浏览器一般是先判断缓存有没有过期，如果没有，直接使用缓存(强制缓存策略)，如果过期了，同时设置了协商缓存，那么就会去判断协商缓存是否过期
    如果没有过期，就会返回304状态码，使用本地缓存，如果过期了，就会重新请求更新数据
  - 协商缓存通过设置last-modified(精确到秒，秒以内多次操作必须使用etag才能检测到) 和 etag 请求， 响应中对应if-modified-since和
    if-none-match


### get请求和post请求的区别 ###
- 网络层面：post请求需要发起两次请求，get请求仅需一次
- 浏览器层面：
  1. get请求的长度限制
  2. get请求需要进行url编码
  3. post请求相对于get请求比较安全一些，因为请求参数不是携带在url上
  4. get请求会被浏览器主动缓存


### 拥塞控制 ###
1. 慢开始(x2)
2. 快重传：当连续三次收到相同的确认包（立即重传）
3. 快恢复(减半并拥塞避免)
4. 拥塞避免(加法增大[线性])


### Http请求方式有哪些 ###
1. GET
2. POST
3. HEAD
4. PUT
5. DELETE
6. CONNECT
7. OPTIONS
8. TRACE


### HTTP/2 特性 ###
1. 二进制分帧： HTTP2中逻辑上的HTTP消息由一个或多个帧组成。HTTP/2采用二进制传输数据，而非1.x的文本格式。HTTP/2 中，同域名下所有通信都在单个连接上完成，该连接可以承载任意数量的双向数据流。多个帧之间可以乱序发送，根据帧首部的流标识可以重新组装。
2. 多路复用： 在HTTP/1.x中，如果想要发送多个请求，必须使用多个TCP连接(浏览器为了控制资源，还会对单个域名有6-8个的TCP连接请求限制)。在HTTP/2中，同域名的所有通信都在单个连接上完成。每个请求都可以带一个31bit的优先值，0表示最大优先级，数值越大优先级越低。
3. 服务端推送： 服务端可以在发送页面HTML时主动推送其它资源，而不用等到浏览器解析到相应位置，发起请求再响应。
4. 头部压缩： HTTP每一次通信都会携带一组头部，用于描述这次通信的的资源、浏览器属性、cookie等，为了减少这块的资源消耗并提升性能， HTTP/2对这些首部采取了压缩策略。
  - 在客户端和服务端使用首部表来跟踪和存储之前发送的键－值对，对于相同的数据，不再通过每次请求和响应发送
  - 首部表在HTTP/2的连接存续期内始终存在，由客户端和服务器共同渐进地更新
  - 每个新的首部键－值对要么被追加到当前表的末尾，要么替换表中之前的值